
# Méthode de détection des antivirus et contournement par les malwares

> Cette présentation ainsi que tous les documents associés et l'éventuelle preuve de concept sont proposés à but éducatif uniquement. Les connaissances introduites et les compétences mentionnées dans ces documents ne doivent en aucun cas être utilisées sur des systèmes d'information sur lesquels vous ne disposez pas d'une autorisation écrite permettant explicitement ces actions.

## 0. Métadonnées

- **Titre** : Évasion des antivirus — notions et enjeux pour un SOC
- **Audience** : étudiants ingénieurs en cybersécurité / personnel SOC débutant
- **Durée** : 20 minutes
- **Objectifs pédagogiques** :
    - Comprendre le rôle et le fonctionnement des AV/EDR/EPP
    - Connaître les grandes familles de techniques d’évasion
    - Savoir comment détecter/mitiger ces techniques en contexte corporate

---

## 1. Pourquoi un antivirus à quoi ça sert ?

- **Mission principale** : réduire la surface d’attaque, détecter et bloquer l’exécution de code malveillant.
- **Valeur ajoutée** :
    - Protection pré-exécution (scan fichiers, signatures)
    - Blocage au runtime (hooking API, sandboxes, heuristiques)
    - Potentielle rétention de télémétries (logs, traces processeur, réseau) pour investigation
- **Limite intrinsèque** : aucune solution unique n’est infaillible — nécessité d’une défense en couches (technique + process + formation).

---

## 2. Comment les antivirus fonctionnent — panorama des méthodes de détection

### 2.1 Détection statique

- **Principe** : signature binaire (hash), patterns, règles d'analyse, heuristiques sur l’entropie/imports/sections.
- **Points forts** : rapide, faible coût CPU.
- **Limites** : fragile face à packing, chiffrement, polymorphisme.

### 2.2 Analyse dynamique / sandboxing

- **Principe** : exécuter l’échantillon dans un environnement contrôlé et observer appels API, accès fichiers, réseau.
- **Points forts** : détecte comportements même si binaire obfusqué.
- **Limites** : coût en ressources, détection par le malware (anti-sandbox), résilience temporelle.

**Note :** Les solutions dédiées à un usage personnel qui implémentent des sandbox ont tendance à accélérer artificiellement l'exécution d'un programme pour paraitre plus transparentes, mais cela les rend détectables. 

### 2.3 Heuristiques et corrélation comportementale

- Détection via règles comportementales (ex : processus qui chiffre des fichiers + contacts C2).
    
- Souvent géré côté EDR ou SIEM avec règles (Sigma).
    

### 2.4 Machine Learning et verdict cloud

- Modèles entraînés sur features (structure binaire, séquence d’appels, patterns réseau).
- Avantage : généralisation
- Risque : faux positifs et dépendance aux données d’entraînement.
- Question sur la vie privée : le serveur qui concentre les échantillons sait qui exécute quel programme et quand.


### 2.5 Généralisation et implémentations des mécanismes d'antivirus — AV, EPP, EDR, ERP

#### 2.5.1 AV (Antivirus)
- **But** : blocage pré-exécution / contrôle fichier par fichier.
- **Fonctions clés** : signatures, heuristiques, quarantaines locales.
- **Visibilité** : locale, centrée sur les fichiers et opérations basiques.
- **Forces / limites** : rapide mais fragile face au fileless, packing, LOLBINs.
#### 2.5.2 PP (Endpoint Protection Platform, AV++)
- **But** : protection préventive étendue de l’endpoint.
- **Fonctions clés** : AV + contrôle applicatif, blocage réputation cloud, sandboxing local, pare-feu.
- **Visibilité** : endpoint + cloud pour réputation.
- **Forces / limites** : bon pour empêcher les menaces connues ; moins orienté post-incident.
#### 2.5.3 EDR (Endpoint Detection & Response)
- **But** : visibilité fine en runtime + outils d’investigation et réponse.
- **Fonctions clés** : collecte d’événements détaillés (process tree, API calls, réseau, mémoire), recherche, playbooks de réponse.
- **Visibilité** : riche, granulaire, utile pour threat hunting.
- **Forces / limites** : détecte comportement anormal mais nécessite SOC/analystes (sinon bruit).
#### 2.5.4 ERP / XDR (Extended / eXpandable Detection & Response)
- **But** : corrélation et orchestration centralisée sur tout le SI (endpoints, réseau, cloud, identités).
- **Fonctions clés** : agrégation multi-source, corrélation, automatisation (SOAR), playbooks cross-domain.
- **Visibilité** : holistique.
- **Forces / limites** : puissant si bien intégré ; lourdeur d’intégration et dépendance à la qualité des télémétries.

**Résumé :** 
- AV/EPP : prévention à la périphérie de l’endpoint 
- EDR : observabilité + réponse au runtime 
- ERP/XDR : corrélation multi-couches et orchestration.

---
### 2.6 Règles & signatures partagées (YARA, Sigma)

#### 2.6.1 YARA

- **Usage** : détection statique / heuristique sur fichiers et sur image mémoire (analyses offline / live).
- **Type** : règles basées sur motifs / chaînes / expressions binaires / conditions temporelles.
- **Où** : scanners, sandboxes, pipelines d’analyse de malwares, EDR (pour l’analyse mémoire).
- **Bonnes pratiques** :
    - Écrire des règles concises et spécifiques (réduire faux positifs).
    - Préférer combinaisons de signatures (strings + magic bytes + size checks).
    - Versionner & tester sur corpus benignes et corpus de malwares connus (en labo).
    - Ajouter métadonnées (author, date, description, tags)

**Exemple**

Détection d'une commande encodée en base64 dans un script powershell

```json
rule Suspicious_PowerShell_EncodedCommand
{
    meta:
        author = "¨Petchou"
        description = "Détecte usage possible de -EncodedCommand (PowerShell) dans un binaire/script"
        reference = "Usage défensif : tri des artefacts"
        date = "2025-11-04"
        tag = "powershell;suspicious"

    strings:
        $enc_cmd = "-EncodedCommand" ascii wide
        $base64_like = /[A-Za-z0-9+\/=]{40,}/

    condition:
        any of ($enc_cmd) and $base64_like
}
```

#### 2.6.2 Sigma
- **Usage** : format agnostique pour écrire des règles de détection sur logs (processevents, sysmon, firewall, proxy, etc.).
- **Type** : règles YAML, portables, convertibles en requêtes adaptées à Splunk, Elastic, QRadar, etc. (via convertisseurs Sigma).
- **Où** : SIEM, EDR, rule repositories du SOC.
- **Bonnes pratiques** :
    - Fournir contexte (description, id, level, tags).
    - Utiliser conditions claires et minimalistes pour réduire faux positifs.
    - Ajouter tests/échantillons, procédures de tuning (whitelist, seuils, timeframes).
    - Tenir des versions des règles (changements, raisonnement).

**Exemple**

Bloquer l'exécution de PowerShell depuis un macro Word

```json
title: PowerShell EncodedCommand launched by MS Word
id: d7f5b2f1-1b2a-4d9e-8cde-4f9a8f6b1a23
status: experimental
description: Detects when powershell.exe is launched with -EncodedCommand and parent process is winword.exe (macro abuse)
author: Petchou
date: 2025/11/04
references:
  - "Defensive example"
tags:
  - attack.execution
  - attack.t1204.002
logsource:
  product: windows
  service: sysmon
detection:
  selection:
    EventID: 1
    Image|endswith: '\powershell.exe'
    CommandLine|contains: '-EncodedCommand'
    ParentImage|endswith: '\winword.exe'
  condition: selection
level: high
falsepositives:
  - legitimate admin automation launching PowerShell from Word macros (rare)
  - internal tooling invoking powershell (tune with parent path/username)

```

#### 2.6.3 Cycle de vie d'une règle

- **Ecriture** : Rédaction de la règle + documentation et métadonnées (raison d’être, date, auteur).
- **Tests** : sur dataset fictif+ dataset d’incidents/échantillons puis dans un environnement isolé.
- **Déployer en staging** : logs en mode audit (alerte mais pas action).
- **Tuner** : ajuster la whitelist, seuils temporels, exclusions de chemins légitimes.
- **Promouvoir en production** : actions automatiques si faible FP ; sinon alerte SOC.
- **Maintenir** : revue périodique et ajustements selon les logs et les besoins.

---

## 3. Le rôle du SOC en entreprise

### 3.1 Le SOC, c'est quoi ce truc ? 

Le Security Operations Center (SOC) n’est pas une boîte noire mystique ou un bouclier magique. C’est une équipe opérationnelle — souvent distante, qu'on ne voit (malheureusement) que quand la production est en feu — dont la mission est d’assurer la détection, l’investigation et la réponse aux incidents de sécurité, tout en maintenant la posture défensive de l’entreprise.

### 3.2 Missions principales

- **Surveillance & détection** : ingérer et corréler télémétries (EDR, logs réseau, proxy, IAM, cloud) pour repérer anomalies et incidents.  
- **Triage & priorisation** : filtrer les alertes (bruit vs réel incident), attribuer sévérité, déclencher playbooks.  
- **Investigation / threat hunting** : recherche proactive d’indicateurs, triage d’alertes complexes, analyses basées MITRE ATT&CK.  
- **Réponse & containment** : isolation d’hôtes, blocage d’IOC, révocation de sessions, coordination avec les équipes IT pour remédiation.  
- **Rétroaction & amélioration continue** : affiner règles, enrichir IOC, documenter post-mortems.

### 3.3 Analyse post-incident

- **Objectifs** : reconstruire la chaîne d’attaque (timeline), identifier l’empreinte (IOCs), estimer l’impact et fournir éléments pour remédiation et poursuites éventuelles.  
- **Activités clé** :
  - **Collecte d’artefacts** : images disque, snapshots mémoire, logs systèmes, captures réseau (PCAP), artefacts cloud.  
  - **Analyse mémoire** : extraction de processus, detection d’injections, récupération de clefs / credentials en mémoire.  
  - **Analyse persistances** : services, tâches planifiées, registry, drivers. Parfois un recours à une équipe de reverse engineering est nécessaire (il peut arriver qu'une équipe - ou au moins un membre - d'un SOC ait les compétences pour réaliser le reverse d'un malware mais la plupart du temps cette tâche est confiée à une équipe dédiée ou à un prestataire).
  - **Réseau & C2** : reconstitution des flux, analyse DNS/TLS, pivot sur infrastructure C2.  
  - **Reporting** : rapport technique + rapport exécutif (impact, temps d’exposition, actions prises).  
- **Organisation** : forensics peut être interne (SOC + équipe forensics) ou externalisé selon criticité et besoins légaux. Conserver chaînes de custody et logs d’accès pour conformité.

### 3.4 Intégration dans le paysage numérique de l'entreprise

- **IT/Infra** : coordination pour isolation, patching, restauration à partir de snapshots.  
- **Legal / conformité** : décider obligations de notification (RGPD, clients, partenaires).  
- **Communication** : plan de communication (interne/externe) piloté par Security + Comms + Legal.

### 3.5 Indicateurs de performance (KPI) pertinents 

Les indicateurs servent surtout à faire plaisir à la hiérarchie qui ne mets jamais les mains dans le cambouis, mais bon... voilà les principaux :

- **MTTD (Mean Time To Detect)**  
- **MTTR (Mean Time To Respond)**  
- **Taux de faux positifs** (pour les règles déployées)  
- **% endpoints couverts par EDR/XDR**  
- **Temps moyen de triage par alerte**

---
## 4. Alors… pourquoi certains malwares passent encore ?

- Parce que la défense est probabiliste, multi-sources, et que les attaquants adaptent leurs méthodes.
- Les axes d’évasion principaux :
    - **Casser la détection statique** (packing, chiffrement, polymorphisme)
    - **Éviter la détection dynamique** (anti-sandbox, checks temporels, interactions humaines)
    - **Ne pas écrire sur disque** (fileless, exécution en mémoire)
    - **Se fondre dans le bruit** (LOLBINs, processus légitimes)
    - **Masquer C2 et IOC** (chiffrement, DGA, steganographie)

---
## 5. Familles de techniques d’évasion (concepts, pas d’instructions)

> Cette section décrit les techniques à haut niveau, avec leurs signaux détectables et contre-mesures recommandées.

### 5.1 Obfuscation & packing

- **Concept** : chiffrer/comprimer le binaire pour rendre la signature statique inutile jusqu’à décompression en runtime.
- **Signaux détectables** : haute entropie, sections PE/ELF atypiques, import table vide.
- **Mitigations** : déballage en sandbox contrôlée, heuristiques d’entropie, extraction d’IOCs au runtime.

### 5.2 Polymorphisme / Métamorphisme

- **Concept** : la forme binaire change à chaque génération alors que le payload logique reste.
- **Signaux** : variations fréquentes avec comportement exécution similaire.
- **Mitigations** : analyse comportementale et fingerprinting de flux d’exécution.

### 5.3 Fileless / exécution en mémoire

- **Concept** : aucun fichier persistant ; code exécuté depuis scripts, processus en mémoire, ou injection.
- **Signaux** : activité PowerShell inhabituelle, chargements de code depuis mémoire, absence d’artéfacts disk.
- **Mitigations** : AMSI (sur Windows), EDR qui instrumente l'API mémoire, monitoring de scripts.

### 5.4 Explosion de l'arbre d'exécution

- **Concept** : Spawn massif de processus enfants qui réalisent des tâches triviales avant de mourir. Permet de créer des leurres (beaucoup utilisé par les logiciels à licence pour éviter le reverse).
- **Signaux** : Activité suspecte/inattendue de la part d'un processus qui disparait rapidement. Répétition d'un même pattern d'exécution par de nombreux processus.
- **Mitigation** : Pas de réelle mesure applicable sans casser des applications ou des jeux protégés par ce système (Denuvo pour les JV, les logiciels Adobe pour obfusquer la validation de la licence). Il faut plutôt essayer de capturer des signaux des processus créés (appels réseau, mémoire ou système.
### 5.5 Process injection / Process hollowing (concept)

- **Concept (haut niveau)** : le malware exécute son code dans le contexte d’un autre processus légitime pour masquer la source réelle.
- **Signaux** : création de processus suivi d’une activité mémoire qui ne correspond pas au binaire sur disque ; mismatch parent/child inhabituel.
- **Mitigations** : monitoring des modifications de mémoire, vérification d’intégrité du code en mémoire, règles EDR basées sur parentage et comportements anormaux.

### 5.6 Abus de binaires légitimes (LOLBINs/LOLBAS)

- **Concept** : utiliser des utilitaires existants (powershell, certutil, rundll32, mshta, etc.) pour réaliser étapes malveillantes.
- **Signaux** : invocation inhabituelle de ces outils (arguments suspects, fréquence, contexte).
- **Mitigations** : baselining, whitelisting contextuel, alerting sur patterns anormaux.

### 5.7 Anti-sandbox & anti-debugging

- **Concept** : vérifier qu’on n’est pas dans un environnement d’analyse (horloge, VM artefacts, absence d’input humain) et rester dormant si sandbox détectée.
- **Signaux** : exécution conditionnelle selon environnement, délais anormalement longs avant action.
- **Mitigations** : améliorer la sandbox (simulateur d’input humain), enrichir les heuristiques temporelles, corrélation de télémétries.

### 5.8 C2 furtif et réseau

- **Concept** : chiffrement, DGA, steganographie, usage de CDN/proxies pour masquer C2.
- **Signaux** : patterns DNS anormaux, connexions HTTPS vers domaines nouvellement créés, traffic chiffré inhabituel.
- **Mitigations** : DNS telemetry, TLS inspection (où permis), détection d’anomalies comportementales réseau.

### 5.9 Exploitation de vulnérabilités & drivers signés

- **Concept** : utiliser vulnérabilités locales ou drivers mal signés pour escalader privilèges / contourner contrôles.
- **Signaux** : tentatives d’installation de drivers, appels système inhabituels.
- **Mitigations** : gestion correcte des patchs, contrôle des signatures de drivers, least privilege.

---
## 7. Résumé des contre-mesures pratiques

- **Défense en profondeur** : EPP + EDR + réseau + SIEM + politique de patching.
- **Harden endpoints** : AppLocker/WHQL, gestion des privilèges, protection mémoire (DEP/ASLR), bloqueurs macros/AMSI.
- **Monitorer ce qui importe** : logs PowerShell, créa. services, écritures sur dossiers sensibles, connexions réseau sortantes.
- **Threat hunting régulier** : chasses basées MITRE ATT&CK, test Atomic, jeu de règles Sigma personnalisé.
- **Mise à jour et gestion des drivers** : empêcher drivers non signés, contrôle d’intégrité.
- **Education** : phishing awareness, restriction d’usage des LOLBINs via policy.



